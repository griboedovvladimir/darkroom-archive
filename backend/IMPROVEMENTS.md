# Улучшения для backend (darkroom-archive/backend)

Этот файл содержит предложения по улучшению бэкенда: быстрые победы (quick wins), более серьёзные изменения архитектуры, рекомендации по тестированию, безопасности и эксплуатации, а также небольшие примеры/рецепты. Для каждого пункта указан примерный приоритет и оценка усилий.

---

## Сводка / приоритеты
- Высокий приоритет:
  - Явная обработка ошибок (middleware)
  - Валидация входящих данных
  - Корректное управление конфигурацией (env + dotenv)
  - Индексация и оптимизация запросов в Mongo
  - Логи и метрики
- Средний приоритет:
  - Разделение слоёв (routes / controllers / services)
  - Тесты (unit/integration)
  - API versioning и документация
- Низкий приоритет / долгосрочно:
  - CI/CD, контейнеризация и production-hardening
  - Миграции схемы/версирование БД
  - Использование типов (TypeScript) в полную силу, DTO/схемы

---

## Quick wins (низкие усилия, большой эффект)

1. Стандартизировать обработку ошибок
   - Вынести общую обработку ошибок в middleware (`errorHandler`) вместо повторяющихся try/catch в каждом роуте.
   - Возвращать предсказуемую структуру ответа `{ error: string, code?: string }`.
   - При разных типах ошибок возвращать соответствующий HTTP статус.

2. Валидация входящих данных
   - Добавить валидацию для `POST /items` и `PUT /items/:id` (например, `Joi` или `express-validator`).
   - Не сохранять документы без необходимых полей (там, где это логично).

3. Конфигурация через env
   - Вынести строки подключения, порт, режим (dev/prod/test), таймауты и пр. в переменные окружения.
   - Использовать библиотеку вроде `dotenv` для локальной разработки.
   - Поддерживать конфигурацию для тестов (`NODE_ENV=test`).

4. Улучшить логику подключения к Mongo
   - Логировать успешное/неуспешное подключение.
   - Поддержать повторные попытки подключения (retry) или корректную остановку при ошибке.
   - Добавить graceful shutdown (закрытие соединения при SIGINT/SIGTERM).

5. Связь с коллекцией: использовать индексы
   - Добавить индекс по полю `code` (если часто ищете по нему): `ItemSchema.index({ code: 1 }, { unique: true })`.
   - Проверить другие частые запросы и добавить необходимые индексы.

---

## Средний уровень — структурные улучшения

1. Разделение ответственности (Controllers / Services / Models)
   - Роуты — принимают запрос и вызывают контроллер.
   - Контроллер — обрабатывает входные данные, вызывает сервис.
   - Сервис — содержит бизнес-логику и взаимодействует с моделью.
   - Это упростит тестирование и масштабирование.

2. DTO / Types (TypeScript)
   - Явно описать shape объектов (интерфейсы/типов) для входа/выхода.
   - Использовать трансформации/переводы данных между слоями.

3. Centralized validation + sanitization
   - Писать middleware, которые валидируют и очищают запросы.
   - Санитизация предотвращает NoSQL injection и XSS.

4. Pagination, filtering и сортировка
   - Для `GET /items` поддержать параметры `limit`, `page`, `sort`, `filter` (с безопасной обработкой).
   - Убедиться, что большие коллекции не возвращаются целиком.

5. Документация API и контрактов
   - Либо оставить Swagger/OpenAPI, либо поддерживать актуальный спек-файл.
   - Автоматизировать проверку спецификации в CI.

---

## Долгосрочные улучшения (высокая сложность, большая ценность)

1. Тестирование
   - Unit-тесты для сервисов и контроллеров (jest).
   - Integration-тесты с in-memory Mongo (mongodb-memory-server) или тестовой БД.
   - Тест покрытие для критичных частей (создание, поиск по code, автоинкремент).

2. CI/CD
   - Запуск линтеров, тестов и статического анализа при PR.
   - Автоматические сборки Docker-образов и деплой (staging/prod).

3. Безопасность
   - Использовать `helmet`, `express-rate-limit`.
   - Проверять зависимости (npm audit / Snyk).
   - Защита от brute-force и limit request body size.
   - Рассмотреть авторизацию/аутентификацию (если потребуется) — JWT / OAuth.

4. Метрики и мониторинг
   - Экспонировать метрики (Prometheus) — количество запросов, ошибки, latency.
   - Настроить алерты на высокую ошибочность или падение БД.

5. Производительность: кеширование
   - Кешировать часто читаемые ресурсы (Redis) там, где это уместно.
   - TTL и инвалидация кеша при изменениях.

---

## Рецепты / примеры (минимальные примеры, которые стоит внедрить)

Пример: структура проекта (рекомендуется)
- backend/
  - server.ts
  - config/
    - index.ts
  - models/
    - item.ts
  - routes/
    - items.ts
  - controllers/
    - itemsController.ts
  - services/
    - itemsService.ts
  - middleware/
    - errorHandler.ts
    - validate.ts
  - tests/
    - unit/
    - integration/
  - utils/
    - logger.ts

Пояснение: такая структура помогает разделять ответственность и делает код тестируемым.

Пример: общая ошибка-обработчик (псевдо)
- добавить файл `middleware/errorHandler.ts` и использовать `app.use(errorHandler)` в конце цепочки middleware.

Пример: подключение graceful shutdown (логика)
- при получении SIGINT/SIGTERM:
  - перестать принимать новые соединения,
  - дождаться завершения текущих запросов,
  - закрыть подключение к Mongo,
  - вызвать process.exit(0).

---

## Конкретные изменения, которые можно вмержить по шагам

1. Добавить `middleware/errorHandler` и заменить try/catch в роутерах на `next(err)` (низкий риск).
2. Добавить `dotenv` и вынести конфиги; заменить хардкод на `process.env.*`.
3. Добавить `express-validator` (или Joi) в роуты `POST /items`, `PUT /items/:id`.
4. Добавить индекс `code` в модель и мигрировать/проверить уникальность.
5. Вынести модель `Item` (уже сделано) и перенести остальные сущности в `models/`.
6. Настроить ESLint + Prettier + husky (pre-commit hook).
7. Написать базовые unit-тесты для сервисов.

---

## Контрольный список перед деплоем в production
- [ ] Безопасные переменные окружения (ключи/пароли в secret manager)
- [ ] Логи настроены на централизованный сбор (например, filebeat/elk или cloud logs)
- [ ] Метрики и алерты включены
- [ ] Тесты в CI проходят
- [ ] Установлены лимиты ресурсов (CPU/Memory) в контейнере
- [ ] Настроен health check и readiness probe (если Kubernetes)

---

## Дополнительные замечания по текущему коду
- Поскольку `Item` использует `strict: false`, нужно контролировать, какие поля приходят, чтобы не захламлять коллекцию мусорными полями.
- В текущей реализации `PUT /items/:id` и `DELETE /items/:id` работают по Mongo `_id`, а `GET /items/:id` — по `code`. Это удобно, но потенциально путано. Рекомендация:
  - Использовать явные endpoints: `/items/code/:code` и `/items/:id` (где `:id` — Mongo id).
  - Либо документировать контракт очень чётко в API-spec.

---

Если хочешь, могу:
- Подготовить конкретные PR-патчи для первых трёх пунктов (errorHandler + dotenv + валидация).
- Написать шаблон `errorHandler.ts` и `validate.ts` под текущую структуру.
- Настроить ESLint / Prettier конфиги.

Выбери, с чего начать, и я сгенерирую необходимые файлы/патчи.